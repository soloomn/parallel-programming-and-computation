#include <iostream>
#include <mpi.h>
using namespace std;
#define n 100 //константа n 100 элементов

int mainlab1(int argc, char* argcv[]) //указатель на командную строчку, и количество параметров в коммандной строке
{
	cout << "initializied lab1 " << " mpi were started " << "\n";

	double m[n], * lm, min, lmin; //вещественные числа массива
	int i, np, size, * len; //целое с длинной, так как len - переменна¤ величина(поэтому пишем указатель *)
	MPI_Status st; //подключение  к MPI
	MPI_Init(&argc, &argcv); //используетс¤ в обменных операци¤х и объедин¤ет все процессы (нужно чтобы узнать кол-во процессов и номер)
	MPI_Comm_size(MPI_COMM_WORLD, &size); //1) им¤ коммуникатора 2)переложить кол-во из 1 пункта (при запуске)
	MPI_Comm_rank(MPI_COMM_WORLD, &np); //номер процесса в np, каждый процесс знает свое им¤
	len = new int[size]; //заполнение длинны
	for (i = 0; i < size; i++) //заполнение массива от 0 до size
		len[i] = n / size; //находим ¤чейки
	len[size - 1] += n % size; //находим остаток от делени¤, size -1 (потому что индексаци¤ нацинаетс¤ с 0)
	lm = new double[len[np]]; //выдел¤ем пам¤ть под локальный массив (один код - дл¤ всех), из одного массива создаем свой маленький.
	if (np == 0) //код дл¤ одного процесса, через условный оператор
	{
		for (i = 0; i < n; i++)
			m[i] = i + 1;
		m[16] = -2;
		for (i = 1; i < size; i++) //нельз¤ отправл¤ть 0 индексу
			MPI_Send(&m[i * len[0]], len[i], MPI_DOUBLE, i, i, MPI_COMM_WORLD);//функци¤ отправки(1. то что мы отправл¤ем первому процессу(буфер данных, велчиина смещени¤), 
		//2.количество процессов (кому отправл¤ем и сколько) 
		//3. куда отправл¤ем (номер процесса получател¤), тэг безопасности (маркируетс¤, гарантирует взаимную однозначность передачи данных) 
		//4. коммуникатор
		min = m[0];
		for (i = 1; i < len[0]; i++)
			if (min > m[i])
				min = m[i];
		for (i = 1; i < size; i++)
		{
			MPI_Recv(&lmin, 1, MPI_DOUBLE, i, i, MPI_COMM_WORLD, &st);
			if (min > lmin)
				min = lmin;
			cout << lmin << " " << min << endl;
		}
	}
	else
	{
		MPI_Recv(lm, len[np], MPI_DOUBLE, 0, np, MPI_COMM_WORLD, &st); //принимаем сообщение, выполн¤ют все кроме 0 индекса, берем то значение которое относитс¤ к номеру
		lmin = lm[0]; //принимаетс¤ кусочек данных, дл¤ поиска локального минумама
		for (i = 1; i < len[np]; i++)
			if (lmin > lm[i])
				lmin = lm[i];
		MPI_Send(&lmin, 1, MPI_DOUBLE, 0, np, MPI_COMM_WORLD); //отправл¤ем в кол-ве одной штуки в 0 процесс
		if (np == size - 1)
			for (i = 0; i < len[size - 1]; i++) //если номер процесса последний, то только на нем все выводим
				cout << lm[i] << " " << np << endl;
	}
	MPI_Finalize(); //освобождает пам¤ть из под служебных объектов
	return 0;
}
